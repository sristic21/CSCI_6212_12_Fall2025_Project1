import time, math
import numpy as np
import matplotlib.pyplot as plt

# Input size (n)
N_vals=[1_000_000, 13_250_000, 25_500_000, 37_750_000, 50_000_000]

# --- Function whose runtime we measure ---
def nested_loop(n):
    a = [1]*(n+1)
    b = [1]*(n+1)
    j = 5.0
    total = 0
    while j < n/2.0:
        k = 5.0
        while k < n:
            total += a[int(j)] * b[int(k)]
            k *= math.sqrt(2)
        j *= math.sqrt(3)
    return total

exp_ns = []
for n in N_vals:
    t0 = time.perf_counter()
    nested_loop(n)
    t1 = time.perf_counter()
    exp_ns.append((t1 - t0) * 1e9)  # one time per n

# --- Fit quadratic in log2(n): T(n) ≈ a*(log2 n)^2 + b*log2 n + c ---
log_n = np.log2(N_vals)
a, b, c = np.polyfit(log_n, exp_ns, 2)
fit_ns = a*log_n**2 + b*log_n + c

# --- Compute scaling constant for reference (C = T_exp / T_theory) ---
scaled_theory = fit_ns
C = np.mean(np.array(exp_ns) / np.array(fit_ns))

# --- Print table ---
print(f"{'n':>5} {'Experimental_Result(ns)':>34} {'Theoretical_Result{log2(n)}':>30} {'Adjusted_Theoretical_Result(ns)':>40}")
print("="*100)
for n, exp, log_val, theo in zip(N_vals, exp_ns, log_n, scaled_theory):
    print(f"{n:12,} {int(exp):20,} {log_val:30} {int(theo):35,}")

print(f"\nScaling constant C ≈ {C:.5f}")

# --- Plot results ---
plt.plot(N_vals, exp_ns, 'o-', label='Experimental')
plt.plot(N_vals, fit_ns, 's--', label='Fitted Theory')

# Set x-axis ticks to exactly the N_vals
plt.xticks(N_vals, [f'{n:}' for n in N_vals], rotation=45)

plt.xlabel('Input size n')
plt.ylabel('Runtime (ns)')
plt.title('Experimental vs Fitted Runtime')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
